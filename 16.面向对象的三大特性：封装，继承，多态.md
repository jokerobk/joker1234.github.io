# 面向对象的三大特性：封装，继承，多态

## 封装

> 封装就是使用特殊的语法，对成员属性和成员方法进行包装，达到保护和隐藏的目的 但是一定注意，不能把成员全部封装死，就失去意义了 被封装的成员主要是供类的内部使用 被特殊语法封装的成员，会有不同的访问的权限

### 封装的级别

```python
封装的级别
    成员   ==> 公有的
    _成员  ==> 受保护的 （约定俗成，而python没有具体实现）
    __成员 ==> 私有的
          公有的 public    受保护的 protected     私有的 private
在类的内部      OK              OK                 OK
在类的外部      OK              No(python可以)      No
```

### 封装的实现

```python
公有的封装：
    定义：默认定义的成员都属于公有成员
    特征：公有的成员可以在任何位置进行访问和操作
受保护封装
		定义：在成员名称前面加一个下划线 _成员名称
		特征：受保护的成员和公有成员一样可以在任何位置进行访问，但是一般不要随便访问和操作受保护成员
私有的封装
		定义：在成员名称前面加两个下划线 __成员名称
		特征：私有的成员只能在当前类的内部去访问和操作，不能在类的外部进行操作
```

### 查看对象的成员

```python
# 查看对象的所以成员
print(ym.__dict__)  # 可以获取当前对象的所有成员信息
# print(Person.__dict__) # 可以获取当前类的所有成员信息

#{'name': '杨幂', '_age': 28, '_Person__sanwei': '60 55 60'}
```

#### 了解：

1. 在python中并没有实现受保护的封装，属于开发者的约定俗成。
2. python中的私有化封装是通过改名策略实现的，并不是真正的私有化

## 继承

### 什么是继承？

> 文化的传承，技艺的传承，衣钵的继承。。。

### 计算机中的继承

> 在面向对象中，一个类去继承父类，那么这个类就拥有了父类中的所有成员（除了私有成员）

### 概念：

- 被其它类继承的类，这个类称为 父类 也叫做 基类 或者 超类
- 继承其它类的类，这个类称为 子类，也叫做 派生类

### 继承的意义：

> 提高代码的重用性，建立新的类与类的关系，方便其它逻辑的操作

### 继承语法格式

```python
class 父类():
	pass

class 子类(父类):
	pass
```

### 继承的特征

- 在不指定继承的父类时，所有类都继承自object类（系统提供） 了解
- 子类继承了父类后，就拥有了父类中的所有成员包括魔术方法（除了私有成员）
- 子类继承父类后，并不会把父类的成员复制给子类，而去引用
- 子类继承父类后可以重写父类中的方法，叫做 重写
- 子类重写父类的方法，依然可以使用`super().父类方法名()`的方式调用父类的方法
- 子类中如果定义了父类中不存在的方法，称为对父类的扩展
- 一个父类可以被多个子类继承，还可以存在 链式继承 。
  - 链式继承：A类继承了B类，B类继承了C类，C类继承了D类。。。

### 单继承和多继承

#### 单继承

> 单继承：一个类只能继承一个父类的方式。

语法格式:

```python
class 父类():
	pass
	
class 子类(父类):
	pass
```

#### 多继承

> 多继承：一个类去继承多个父类的方式。

语法格式:

```python
class 父亲():
	pass
	
class 母亲():
  pass
  
class 子类(父亲,母亲):
	pass
```

#### 菱形继承（钻石继承）

```python
    A
  B   C
    D
# D类去继承了B类和C类，然后B类和C类又分别继承了A类，这种继承关系称为 菱形继承
```

问题：在这种菱形继承关系中，类与类的关系，及super()调用时的顺序

```python
'''
在定义类后，程序会自动生成一个继承的列表 MRO （Method Realtion Order） 方法关系列表
MRO列表生成原则：
	1. 子类永远在父类的前面
	2. 同一等级的类，按照子类中的继承顺序摆放
	3. 先子类，后父类的顺序原则，最终的类时系统提供的object类
MRO的调用方法
类名.mro()
'''
C.mro()
# [<class 'C'>, <class 'F'>, <class 'M'>, <class 'HuMan'>, <class 'object'>]

# super()在调用时，并不是查找父类，而是去MRO列表上找上一个类。
# super()方法在调用时，会自动把当前self传入到上一级的类的方法中
```

#### 类关系检测 issubclass()

> issubclass() 检测一个类是否时另一个类的子类

```python
# 检测一个类是否是另一个类的子类
res = issubclass(D,B) # True 检测D类是不是B类的子类
res = issubclass(D,C) # True 检测D类是不是C类的子类
res = issubclass(D,A) # True 检测D类是不是A类的子类
res = issubclass(A,D) # False 检测A类是不是D类的子类
```

## 多态

> 对于同一个方法，由于调用的对象不同，产生了不同形态的结果

示例：

```python
#  多态 普通版本
# 对于同一个方法，由于调用的对象不同（或者传入的对象不同），最终实现了不同的结果

# 定义电脑类
class Computer():
    # 在电脑类中定义一个 sub 的规范的接口 方法
    def usb(self,obj):
        obj.start()

# 定义鼠标类
class Mouse():
    def start(self):
        print('鼠标启动成功，可以双击单击嗨起来。。。')

# 定义键盘类
class KeyBord():
    def start(self):
        print('键盘启动成功了，赶紧双击666。。。')

# 定义 U盘 类
class Udisk():
    def start(self):
        print('U盘启动了，赶紧检查一下我的种子还在不在。。。')

# 实例化对象
c = Computer()  # 电脑对象
m = Mouse()     # 鼠标对象
k = KeyBord()   # 键盘对象
u = Udisk()     # u盘对象


# 把不同的设备插入到电脑的usb的接口中
c.usb(m)
c.usb(k)
c.usb(u)
```

